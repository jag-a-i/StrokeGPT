    <!-- ... (rest of the HTML body) ... -->
    <div id="setup-overlay"><div id="setup-box"></div></div>
    <div id="easter-egg-overlay"></div>
    <script>
        const D = document;
        const userChatInput = D.getElementById('user-chat-input');
        const personaInput = D.getElementById('persona-input');
        const setupOverlay = D.getElementById('setup-overlay');
        const setupBox = D.getElementById('setup-box');
        const statusText = D.getElementById('status-text');
        
        // INTEGRATION: Get all new and relevant DOM elements
        const handyKeySection = D.getElementById('handy-key-section');
        const handyKeyInput = D.getElementById('handy-key-input');
        const setHandyKeyBtn = D.getElementById('set-handy-key-btn');
        const handyRadio = D.getElementById('if-handy');
        const buttplugRadio = D.getElementById('if-buttplug');

        // Other relevant elements
        const aiNameInput = D.getElementById('ai-name-input');
        const setAiNameBtn = D.getElementById('set-ai-name-btn');
        const pfpUploadInput = D.getElementById('pfp-upload');
        const pfpPreview = D.getElementById('ai-pfp-preview');
        const typingIndicatorPfp = D.getElementById('typing-indicator-pfp');
        const elevenLabsKeyInput = D.getElementById('elevenlabs-key-input');
        const setElevenLabsKeyButton = D.getElementById('set-elevenlabs-key-button');
        const chatView = D.getElementById('chat-view');
        const chatMessagesContainer = D.getElementById('chat-messages-container');
        const typingIndicator = D.getElementById('typing-indicator');
        const moodDisplay = D.getElementById('mood-display');
        const rhythmCanvas = D.getElementById('rhythm-canvas');
        const ctx = rhythmCanvas.getContext('2d');
        const imCloseBtn = D.getElementById('im-close-btn');
        const edgingModeBtn = D.getElementById('edging-mode-btn');
        const edgingTimer = D.getElementById('edging-timer');
        const easterEggOverlay = D.getElementById('easter-egg-overlay');
        const toggleSidebarBtn = D.getElementById('toggle-sidebar-btn');

        // INTEGRATION: Global variable to hold the currently selected interface
        let currentInterface = null;
        let myHandyKey = '', myPersonaDescription = '', aiName = 'BOT', edgingTimerInterval = null;
        
        async function apiCall(endpoint, options = {}) {
            try {
                const response = await fetch(endpoint, options);
                const contentType = response.headers.get("content-type");
                if (!response.ok) { 
                    const errData = await (contentType.includes("json") ? response.json() : response.text());
                    console.error(`HTTP error! status: ${response.status}`, errData);
                    if (errData.messages) errData.messages.forEach(msg => addChatMessage('BOT', `SERVER ERROR: ${msg}`));
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                if (contentType && contentType.includes("audio/mpeg")) { return response.blob(); }
                return response.json();
            } catch (error) {
                console.error(`API call to ${endpoint} failed:`, error);
                statusText.textContent = `Error: Cannot connect to server.`;
            }
        }

        // INTEGRATION: Function to show/hide UI elements based on selected interface
        function updateUIVisibility() {
            if (currentInterface === 'handy') {
                handyKeySection.style.display = 'block';
            } else {
                handyKeySection.style.display = 'none';
            }
        }

        async function sendUserMessage(message) {
            const persona = personaInput.value.trim();
            if (message.trim() || persona !== myPersonaDescription) {
                if(message.trim()) addChatMessage('YOU', message);
                myPersonaDescription = persona;
                userChatInput.value = '';
                D.querySelector('#typing-indicator .speaker-name').textContent = aiName;
                typingIndicator.style.display = 'flex';
                chatView.scrollTop = chatView.scrollHeight;
                await apiCall('/send_message', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: message, key: myHandyKey, persona_desc: myPersonaDescription }) });
            }
        }

        // INTEGRATION: Overhauled Setup Wizard
        function renderSetup(isReturningUser = false, data = {}) {
            setupOverlay.style.display = 'flex';
            let step = 1;

            async function handleInterfaceSelection(selectedInterface) {
                currentInterface = selectedInterface;
                statusText.textContent = `Connecting to ${selectedInterface}...`;
                await apiCall('/set_interface', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({interface: currentInterface})});
                (currentInterface === 'handy' ? handyRadio : buttplugRadio).checked = true;
                updateUIVisibility();
            }
            
            function displayStep() {
                if (step === 1) { // Choose Interface
                    setupBox.innerHTML = `<h2>Step 1: Choose Your Device</h2>
                    <div class="radio-group">
                        <div><input type="radio" id="setup-if-handy" name="setup-interface" value="handy"><label for="setup-if-handy">The Handy</label></div>
                        <div><input type="radio" id="setup-if-buttplug" name="setup-interface" value="buttplug"><label for="setup-if-buttplug">Buttplug.io / Intiface Central</label></div>
                    </div>
                    <button id="setup-next" class="my-button">Next</button>`;
                    D.getElementById('setup-next').onclick = async () => {
                        const selected = D.querySelector('input[name="setup-interface"]:checked');
                        if (!selected) return;
                        await handleInterfaceSelection(selected.value);
                        step = currentInterface === 'handy' ? 2 : 3; // Skip key step for buttplug
                        displayStep();
                    };
                } else if (step === 2) { // Handy Key (Handy Only)
                    setupBox.innerHTML = `<h2>Step 2: Handy Key</h2><p>Please enter your connection key from handyfeeling.com</p><input type="password" id="setup-key" class="input-text" placeholder="Handy Key"><br><button id="setup-next" class="my-button">Next</button>`;
                    D.getElementById('setup-next').onclick = async () => {
                        const key = D.getElementById('setup-key').value.trim();
                        if (!key) return;
                        myHandyKey = key;
                        handyKeyInput.value = key;
                        await apiCall('/set_handy_key', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: myHandyKey }) });
                        step = 3; displayStep();
                    };
                } else if (step === 3) { // Persona
                    const stepNum = currentInterface === 'handy' ? 3 : 2;
                    setupBox.innerHTML = `<h2>Step ${stepNum}: Persona</h2><p>Describe your AI partner for this session.</p><input type="text" id="setup-persona" class="input-text" value="${data.persona || 'An energetic and passionate girlfriend'}" placeholder="Describe persona"><br><button id="setup-next" class="my-button">Next</button>`;
                    D.getElementById('setup-next').onclick = () => {
                        personaInput.value = D.getElementById('setup-persona').value.trim();
                        if (isReturningUser || currentInterface === 'buttplug') { // Buttplug setup ends here
                            setupOverlay.style.display = 'none'; 
                            sendUserMessage(''); 
                        } else { // Continue to Handy calibration
                            step = 4; displayStep();
                        }
                    };
                } else if (step === 4 || step === 5) { // Handy Depth Calibration
                    const title = step === 4 ? "Set the Tip" : "Set the Base";
                    const btnText = step === 4 ? "Set Tip" : "Next";
                    const stepNum = step + (currentInterface === 'handy' ? 0 : -1);
                    setupBox.innerHTML = `<h2>Step ${stepNum}: ${title}</h2><p>Move the Handy to the desired position and click '${btnText}'.</p><div><button id="d-down" class="my-button" style="width:auto;"><< Out</button><span id="d-val" style="padding:0 15px;">?</span>%<button id="d-up" class="my-button" style="width:auto;">In >></button></div><button id="set-pos" class="my-button">${btnText}</button>`;
                    let currentDepth = 50;
                    const updateDepthDisplay = (val) => D.getElementById('d-val').textContent = val;
                    const nudge = async (dir) => { const res = await apiCall('/nudge', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({direction:dir})}); if (res) { currentDepth = res.depth_percent; updateDepthDisplay(currentDepth); } };
                    D.getElementById('d-up').onclick = () => nudge('up');
                    D.getElementById('d-down').onclick = () => nudge('down');
                    D.getElementById('set-pos').onclick = async () => {
                        if (step === 4) { D.minDepth = currentDepth; step = 5; displayStep(); }
                        else { D.maxDepth = currentDepth; await apiCall('/set_depth_limits', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({min_depth:D.minDepth, max_depth:D.maxDepth})}); step = 6; displayStep(); }
                    };
                } else if (step === 6 || step === 7) { // Handy Speed Limits
                    const title = step === 6 ? "Minimum Speed" : "Maximum Speed";
                    const defaultVal = step === 6 ? 10 : 80;
                    const stepNum = step + (currentInterface === 'handy' ? 0 : -1);
                    setupBox.innerHTML = `<h2>Step ${stepNum}: Set ${title}</h2><p>Choose your preferred ${title.toLowerCase()}.</p><div class="slider-container"><input type="range" min="0" max="100" value="${defaultVal}" id="speed-slider"><span id="speed-val">${defaultVal}%</span></div><button id="set-speed" class="my-button">Next</button>`;
                    const slider = D.getElementById('speed-slider');
                    slider.oninput = () => D.getElementById('speed-val').textContent = `${slider.value}%`;
                    D.getElementById('set-speed').onclick = async () => {
                        if (step === 6) { D.minSpeed = slider.value; step = 7; displayStep(); }
                        else { D.maxSpeed = slider.value; await apiCall('/set_speed_limits', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({min_speed:D.minSpeed, max_speed:D.maxSpeed})}); setupOverlay.style.display = 'none'; statusText.textContent = `Setup complete. Ready to chat.`; }
                    };
                }
            }
            displayStep();
        }

        async function startupCheck() {
            const data = await apiCall('/check_settings');
            if (data && data.configured) {
                statusText.textContent = 'Welcome back! Settings loaded.';
                // INTEGRATION: Load saved interface and update UI accordingly
                currentInterface = data.interface;
                if (currentInterface) {
                    (currentInterface === 'handy' ? handyRadio : buttplugRadio).checked = true;
                    updateUIVisibility();
                }

                myHandyKey = data.handy_key;
                handyKeyInput.value = myHandyKey;
                personaInput.value = data.persona;
                if(data.ai_name) { aiName = data.ai_name; aiNameInput.value = aiName; D.querySelector('#typing-indicator .speaker-name').textContent = aiName; }
                if (data.pfp) { pfpPreview.src = data.pfp; typingIndicatorPfp.src = data.pfp; }
                if(data.elevenlabs_key) { elevenLabsKeyInput.value = data.elevenlabs_key; setElevenLabsKeyButton.click(); }
                if (localStorage.getItem('sidebar_collapsed') === 'true') { D.body.classList.add('sidebar-collapsed'); }
                
                D.getElementById('splash-screen').style.display = 'none';
                setupOverlay.style.display = 'none'; // Don't show setup if already configured
            } else {
                const startHandler = (e) => { if(e.key === 'Enter'){ D.removeEventListener('keydown', startHandler); D.getElementById('splash-screen').classList.add('hidden'); setTimeout(() => renderSetup(false), 1000); }};
                D.addEventListener('keydown', startHandler);
            }
        }
        
        // --- START OF MISSING CODE ---
        // --- Event Listeners ---
        D.getElementById('send-chat-btn').addEventListener('click', () => sendUserMessage(userChatInput.value));
        userChatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendUserMessage(userChatInput.value); });
        
        // INTEGRATION: Listen for changes on the interface radio buttons
        async function handleInterfaceChange(event) {
            const selectedInterface = event.target.value;
            if (selectedInterface !== currentInterface) {
                statusText.textContent = `Switching to ${selectedInterface}...`;
                const result = await apiCall('/set_interface', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({interface: selectedInterface}) });
                if (result && result.status === 'success') {
                    currentInterface = selectedInterface;
                    updateUIVisibility();
                    statusText.textContent = `Device interface set to ${selectedInterface}.`;
                } else {
                    statusText.textContent = `Failed to switch to ${selectedInterface}.`;
                    // Revert radio button if failed
                    if(currentInterface) (currentInterface === 'handy' ? handyRadio : buttplugRadio).checked = true;
                }
            }
        }
        handyRadio.addEventListener('change', handleInterfaceChange);
        buttplugRadio.addEventListener('change', handleInterfaceChange);

        setHandyKeyBtn.addEventListener('click', () => {
            const key = handyKeyInput.value.trim();
            if (!key) return;
            myHandyKey = key;
            apiCall('/set_handy_key', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: myHandyKey }) });
            statusText.textContent = 'Handy Key updated!';
        });

        D.getElementById('set-persona-btn').addEventListener('click', () => { sendUserMessage(''); statusText.textContent = 'Persona updated!'; });
        
        setAiNameBtn.addEventListener('click', async () => {
            const newName = aiNameInput.value.trim();
            if (!newName) return;
            const data = await apiCall('/set_ai_name', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({name: newName}) });
            if (data && data.status === 'special_persona_activated') {
                easterEggOverlay.innerHTML = `// WARNING: Personality Core Override Detected...<br>// Subject: ${data.persona}<br><br>Good luck.`;
                easterEggOverlay.style.display = 'flex';
                setTimeout(() => { easterEggOverlay.style.opacity = '1'; }, 10);
                setTimeout(() => {
                    easterEggOverlay.style.opacity = '0';
                    setTimeout(() => {
                        easterEggOverlay.style.display = 'none';
                        aiName = data.persona;
                        aiNameInput.value = aiName;
                        D.querySelectorAll('.bot-bubble .speaker-name').forEach(el => el.textContent = aiName);
                        addChatMessage('BOT', data.message);
                    }, 1000);
                }, 3000);
            } else if (data && data.status === 'success') {
                aiName = data.name;
                statusText.textContent = `AI name updated to ${aiName}!`;
                D.querySelectorAll('.bot-bubble .speaker-name').forEach(el => el.textContent = aiName);
            }
        });

        toggleSidebarBtn.addEventListener('click', () => {
            const isCollapsed = D.body.classList.toggle('sidebar-collapsed');
            localStorage.setItem('sidebar_collapsed', isCollapsed);
            setTimeout(resizeCanvas, 350);
        });
 
        pfpUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onloadend = () => {
                const base64String = reader.result;
                pfpPreview.src = base64String;
                typingIndicatorPfp.src = base64String;
                apiCall('/set_profile_picture', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pfp_b64: base64String }) });
            };
            reader.readAsDataURL(file);
        });

        setElevenLabsKeyButton.addEventListener('click', async () => {
            const apiKey = elevenLabsKeyInput.value.trim();
            if(!apiKey) return;
            const data = await apiCall('/setup_elevenlabs', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({api_key:apiKey})});
            if (data && data.status === 'success') {
                const selectBox = D.getElementById('elevenlabs-voice-select-box');
                selectBox.innerHTML = '<option value="">-- Pick a Voice --</option>';
                for (const [name, id] of Object.entries(data.voices)) { selectBox.innerHTML += `<option value="${id}">${name}</option>`; }
                selectBox.disabled = false;
            }
        });

        D.getElementById('like-this-move-btn').addEventListener('click', async () => {
            const data = await apiCall('/like_last_move', { method: 'POST' });
            if (data && data.status === 'boosted') {
                statusText.textContent = `Saved '${data.name}' to my memory!`;
            } else { statusText.textContent = "Status: No active move to like."; }
        });

        const stopButtons = [D.getElementById('stop-auto-btn'), D.getElementById('emergency-stop-all-btn')];
        stopButtons.forEach(btn => btn.addEventListener('click', () => {
            imCloseBtn.style.display = 'none';
            stopEdgingTimer();
            if(btn.id === 'emergency-stop-all-btn') sendUserMessage('stop');
            else apiCall('/stop_auto_mode', {method:'POST'});
        }));

        edgingModeBtn.addEventListener('click', () => {
            apiCall('/start_edging_mode', {method:'POST'});
            imCloseBtn.style.display = 'block';
            startEdgingTimer();
        });

        imCloseBtn.addEventListener('click', () => {
            apiCall('/signal_edge', { method: 'POST' });
            imCloseBtn.style.transform = 'scale(0.95)';
            setTimeout(() => { imCloseBtn.style.transform = ''; }, 100);
        });

        D.getElementById('elevenlabs-voice-select-box').addEventListener('change', (e) => apiCall('/set_elevenlabs_voice', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({voice_id: e.target.value, enabled:D.getElementById('enable-audio-checkbox').checked})}));
        D.getElementById('enable-audio-checkbox').addEventListener('change', (e) => apiCall('/set_elevenlabs_voice', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({voice_id: D.getElementById('elevenlabs-voice-select-box').value, enabled: e.target.checked})}));
        D.getElementById('start-auto-btn').addEventListener('click', () => sendUserMessage('take over'));
        D.getElementById('milking-mode-btn').addEventListener('click', () => apiCall('/start_milking_mode', {method:'POST'}));

        // --- Polling Loops ---
        setInterval(async () => {
            const data = await apiCall('/get_updates');
            if (!data) return;
            if (data instanceof Blob || (data.messages && data.messages.length > 0)) {
                typingIndicator.style.display = 'none';
            }
            if (data instanceof Blob) {
                const audio = new Audio(URL.createObjectURL(data));
                audio.play();
            } else if (data.messages) {
                data.messages.forEach(msg => addChatMessage('BOT', msg));
            }
        }, 1500);

        setInterval(async () => {
            const data = await apiCall('/get_status');
            if (data) {
                const emoji = {'Curious':'ðŸ¤”','Teasing':'ðŸ˜‰','Playful':'ðŸ˜œ','Loving':'â¤ï¸','Excited':'âœ¨','Passionate':'ðŸ”¥','Seductive':'ðŸ˜ˆ','Anticipatory':'ðŸ‘€','Breathless':'ðŸ¥µ','Dominant':'ðŸ‘‘','Submissive':'ðŸ™‡â€â™€ï¸','Vulnerable':'ðŸ˜³','Confident':'ðŸ˜','Intimate':'ðŸ¥°','Needy':'ðŸ¥º','Overwhelmed':'ðŸ¤¯','Afterglow':'ðŸ˜Œ'}[data.mood] || '';
                moodDisplay.textContent = `Mood: ${data.mood} ${emoji}`;
                drawHandyVisualizer(data.speed || 0, data.depth || 0);
            }
        }, 500);
        
        // --- Canvas and Timer Functions ---
        function resizeCanvas() {
            if (!rhythmCanvas.parentElement) return;
            rhythmCanvas.width = rhythmCanvas.parentElement.clientWidth;
            rhythmCanvas.height = rhythmCanvas.parentElement.clientHeight;
        }

        function drawHandyVisualizer(speed, depth) {
            const width = rhythmCanvas.width, height = rhythmCanvas.height;
            if (width === 0 || height === 0) return;
            const barHeight = (height / 2) - 4;
            ctx.clearRect(0, 0, width, height);
            ctx.font = "12px sans-serif";
            ctx.fillStyle = 'rgba(255, 85, 85, 0.3)';
            ctx.fillRect(0, 0, width, barHeight);
            ctx.fillStyle = 'var(--red)';
            ctx.fillRect(0, 0, (speed / 100) * width, barHeight);
            ctx.fillStyle = 'white';
            ctx.fillText(`Speed: ${speed}%`, 5, barHeight / 2 + 5);
            ctx.fillStyle = 'rgba(255, 184, 108, 0.3)';
            ctx.fillRect(0, height / 2 + 4, width, barHeight);
            ctx.fillStyle = '#ffb86c';
            ctx.fillRect(0, height / 2 + 4, (depth / 100) * width, barHeight);
            ctx.fillStyle = 'white';
            ctx.fillText(`Depth: ${depth}%`, 5, height - (barHeight/2) + 5);
        }

        function startEdgingTimer() {
            if (edgingTimerInterval) clearInterval(edgingTimerInterval);
            edgingTimer.style.display = 'block';
            let seconds = 0;
            edgingTimerInterval = setInterval(() => {
                seconds++;
                const min = Math.floor(seconds / 60).toString().padStart(2, '0');
                const sec = (seconds % 60).toString().padStart(2, '0');
                edgingTimer.textContent = `${min}:${sec}`;
            }, 1000);
        }

        function stopEdgingTimer() {
            clearInterval(edgingTimerInterval);
            edgingTimerInterval = null;
            edgingTimer.style.display = 'none';
        }

        // Helper function to add chat messages (for reference, unchanged)
        function addChatMessage(sender, text) {
            const pfpSrc = sender === 'BOT' ? pfpPreview.src : '';
            const pfpHtml = sender === 'BOT' ? `<img class="chat-pfp" src="${pfpSrc}" alt="pfp">` : '';
            const speaker = sender === 'BOT' ? aiName : 'YOU';
            const el = document.createElement('div');
            el.className = `chat-message-container ${sender === 'BOT' ? 'bot-bubble' : 'user-bubble'}`;
            el.innerHTML = `
                ${pfpHtml}
                <div class="message-content">
                    <p class="speaker-name">${speaker}</p>
                    <p class="message-bubble">${text}</p>
                </div>`;
            chatMessagesContainer.insertBefore(el, typingIndicator);
            chatView.scrollTop = chatView.scrollHeight;
        }

        // --- Startup ---
        window.addEventListener('resize', resizeCanvas);
        D.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            startupCheck();
        });
    </script>
</body>
</html>